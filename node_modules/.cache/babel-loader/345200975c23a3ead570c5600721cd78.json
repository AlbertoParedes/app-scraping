{"ast":null,"code":"function newLine(output) {\n  output.content += '\\r\\n';\n  var i;\n\n  for (i = 0; i < output.level; i++) {\n    output.content += output.options.indentation;\n  }\n}\n\nfunction appendContent(output, content) {\n  output.content += content;\n}\n\nfunction processNode(node, output, preserveSpace) {\n  if (node.name === '#text' || node.name === '#comment') {\n    processContentNode(node, output, preserveSpace);\n  } else {\n    // Assuming that we only have 3 types of node (#text, #comment and element)\n    processElement(node, output, preserveSpace);\n  }\n}\n\nfunction processContentNode(node, output, preserveSpace) {\n  if (!preserveSpace && output.content.length > 0) {\n    newLine(output);\n  }\n\n  appendContent(output, node.content);\n}\n\nfunction processElement(node, output, preserveSpace) {\n  if (!preserveSpace && output.content.length > 0) {\n    newLine(output);\n  }\n\n  appendContent(output, '<' + node.name);\n  processAttributes(output, node.attributes);\n\n  if (node.children === null) {\n    // self-closing node\n    appendContent(output, '/>');\n  } else {\n    appendContent(output, '>');\n    output.level++;\n    var nodePreserveSpace = node.attributes['xml:space'] === 'preserve';\n\n    if (!nodePreserveSpace && output.options.collapseContent) {\n      var containsTextNodes = node.children.some(function (child) {\n        return child.name === '#text';\n      });\n\n      if (containsTextNodes) {\n        nodePreserveSpace = true;\n      }\n    }\n\n    node.children.forEach(function (child) {\n      processNode(child, output, preserveSpace || nodePreserveSpace);\n    });\n    output.level--;\n\n    if (!preserveSpace && !nodePreserveSpace) {\n      newLine(output);\n    }\n\n    appendContent(output, '</' + node.name + '>');\n  }\n}\n\nfunction processAttributes(output, attributes) {\n  Object.keys(attributes).forEach(function (attr) {\n    appendContent(output, ' ' + attr + '=\"' + attributes[attr] + '\"');\n  });\n}\n\nfunction processDeclaration(declaration, output) {\n  if (declaration) {\n    appendContent(output, '<?xml');\n    processAttributes(output, declaration.attributes);\n    appendContent(output, '?>');\n  }\n}\n/**\n * Converts the given XML into human readable format.\n *\n * @param {String} xml\n * @param {Object} options\n *  @config {Boolean} [debug=false] displays a tree of the parsed XML before formatting\n *  @config {String} [indentation='    '] The value used for indentation\n *  @config {Boolean} [stripComments=false] True to strip the comments\n *  @config {Boolean} [collapseContent=false] True to keep content in the same line as the element. Only works if element contains at least one text node\n * @returns {string}\n */\n\n\nfunction format(xml, options) {\n  options = options || {};\n  options.debug = options.debug === true;\n  options.indentation = options.indentation || '    ';\n  options.stripComments = options.stripComments === true;\n  options.collapseContent = options.collapseContent === true;\n\n  var parse = require('xml-parser-xo');\n\n  var parsedXml = parse(xml, {\n    stripComments: options.stripComments\n  });\n\n  if (options.debug) {\n    var inspect = require('util').inspect;\n\n    console.log(inspect(parsedXml, {\n      colors: true,\n      depth: Infinity\n    }));\n  }\n\n  var output = {\n    content: '',\n    level: 0,\n    options: options\n  };\n  processDeclaration(parsedXml.declaration, output);\n  parsedXml.children.forEach(function (child) {\n    processNode(child, output, false);\n  });\n  return output.content;\n}\n\nmodule.exports = format;","map":null,"metadata":{},"sourceType":"script"}